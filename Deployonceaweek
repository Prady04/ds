<p><strong>Moving to Deploy once a week</strong> </p>
<h2 id="keys-to-success">Keys to success</h2>
<h2 id="-">-----------------</h2>
<ul>
<li><p>Tracking of deploy frequency and change lead time.</p>
</li>
<li><p>Well-defined source control, code review, &amp; reproducible CI builds.</p>
</li>
<li><p>A mechanism for intra-team communication so they know what and when changes will be deployed.</p>
</li>
<li><p>Support culture that gives the team confidence that it’s OK to deploy, and to handle things if a deploy goes poorly.</p>
</li>
<li><p>A clear “owner” for deploys. Everyone on the team needs to know how they fit within the process, and who to look to if they have
questions or concerns.</p>
</li>
</ul>
<p><strong>Moving to Deploy once a week</strong></p>
<h3 id="measurements-for-one-deploy-a-week">Measurements for One Deploy a Week</h3>
<h1 id="-">-----------------------------------</h1>
<h2 id="deploy-frequency-and-change-lead-time-">Deploy Frequency and Change Lead Time.</h2>
<ul>
<li>Change Failure Rate and MTTR, more important when we start moving to daily deploys.</li>
<li><p>To achieve a Deploy Frequency of once per week, wer goal is to drive Change Lead Time to at or below 5 days.</p>
</li>
<li><p>we can achieve this by reducing the batch size.</p>
<h2 id="tooling-that-provides-at-least-the-following-capabilities-">Tooling that provides at least the following capabilities:</h2>
<h3 id="minimum">Minimum</h3>
</li>
<li><p>Track and compare Deploy Frequency and Change Lead Time
trends over customizable periods.</p>
</li>
<li><p>Drill down on Deploy Frequency and Change Lead Time by codebases and flags.</p>
</li>
<li><p>Drill into Change Lead Time to see where time is being spent, such as time spent on coding, code reviews, and deploys.</p>
</li>
<li><p>Identify outliers in deploys.</p>
</li>
</ul>
<h3 id="strech">Strech</h3>
<ul>
<li><p>Teams/Slack deploy notifications to provide visibility when 
changes are deployed</p>
</li>
<li><p>Teams/Slack deploy notifications to authors of change so they can instantly know when things are deployed and own their changes.</p>
</li>
<li><p>Automated checks against batch size, triggering either a notification
or an approval process when it finds the batch size is too large.</p>
</li>
</ul>
<h2 id="development-practices-for-one-deploy-a-week">Development Practices for One Deploy a Week</h2>
<p><strong> repeatable deployment process that doesn’t take longer than X (X&lt;6) hours for an individual to perform. </strong></p>
<h2 id="practices-">Practices:</h2>
<h3 id="source-control">Source control</h3>
<ul>
<li><p>developer branches for new changes</p>
</li>
<li><p>“release” branch that is always in a deployable state.</p>
</li>
<li><p>Developer branches are merged into this branch</p>
</li>
<li><p>Code reviews</p>
</li>
<li><p>mechanism for accepting or rejecting changes into release branch</p>
</li>
<li><p>using pull requests to review new changes, and</p>
</li>
<li><p>well-defined process for merging these changes</p>
</li>
</ul>
<h3 id="testing">Testing</h3>
<ul>
<li><p>at least 50% unit test coverage</p>
</li>
<li><p>unit tests are at most 20% flakey</p>
</li>
<li>unit tests run on every code commit</li>
</ul>
<h3 id="deployments">Deployments</h3>
<ul>
<li><p>mostly automated continuous delivery pipeline in place that can build a “release” from our “release” branch</p>
</li>
<li><p>we have a well-defined production environment and a strong understanding of how changes affect this environment</p>
</li>
</ul>
<h3 id="observability">Observability</h3>
<ul>
<li>we have basic observability in place, such that we can judge the
success of our changes to production.</li>
</ul>
<h2 id="communications-for-one-deploy-a-week">Communications for One Deploy a Week</h2>
<h3 id="developer-communication">Developer communication</h3>
<ul>
<li><p>well-defined day / time for when changes need to be integrated into  release branch such that they will ship with the weekly deploy.</p>
</li>
<li><p>well-defined window of when the changes will be live in
production.</p>
</li>
<li><p>well-defined understanding of who is responsible for determining if a deploy is successful. </p>
</li>
<li><p>This can be a build engineer,
automated alerts, or the developers who made the changes. Theimportant thing is to know who makes the call to rollback or keep
our changes live.</p>
</li>
</ul>
<h3 id="intra-team-communication">Intra-team communication</h3>
<ul>
<li>way for Product Owners, Engineering Managers, and
developers to know when a deploy has completed and what was
included.</li>
</ul>
<h3 id="issue-tracking">Issue tracking</h3>
<ul>
<li>issue tracker</li>
<li>Real-time chat</li>
<li>mechanism for developers and those who own the
deploy to have real-time communication; e.g., via Slack/teams.<h3 id="visibility">Visibility</h3>
</li>
<li>a way to know, even if it’s cumbersome, what code and
high-level tasks have been deployed.<h3 id="knowledge-sharing">Knowledge sharing</h3>
</li>
<li>we have some form of documentation that describes how our
deployment process works, who owns it and who is a point of
contact to find out more. </li>
</ul>
<h2 id="culture">Culture</h2>
<h3 id="developers">Developers</h3>
<ul>
<li><p>Developers need to understand and buy into the team&#39;s dev loop.</p>
</li>
<li><p>They need to be trying to make smaller changes and target their
changes to deploy windows.</p>
</li>
<li><p>They need to agree that a break in the
release branch trumps other concerns and will be fixed immediately.</p>
</li>
</ul>
<h3 id="mechanisms-to-achieve-">Mechanisms to achieve:</h3>
<ul>
<li><p>Weekly or bi-weekly sprint planning can help set the size of tasks
and create a team agreement on how tasks will fit into this window.</p>
</li>
<li><p>Automated CI against the release branch and team-wide visibility
into those results to help the team keep the release buildable.</p>
</li>
<li><p>Maintaining a “disturbed” role on a team where it’s clear whose job it
is to keep the release branch buildable.</p>
</li>
</ul>
<h3 id="engineering-managers">Engineering Managers</h3>
<ul>
<li><p>Engineering Managers need to shift from putting in processes that
help the team play defense (e.g., “How can we add processes to slow
down and make sure our 3-month release has no bugs and is “safe” to
ship?), to </p>
</li>
<li><p>putting in processes that help the team play offense (e.g.,
“How do we keep the code flowing? What can we do to ship smaller
changes and quick fixes if we make a mistake?”).</p>
</li>
</ul>
<h3 id="mechanisms-to-achieve-">Mechanisms to achieve:</h3>
<ul>
<li><p>Put in place processes that facilitate communication such as
recurring planning meetings, code review and weekly demos.</p>
</li>
<li><p>Commit to dedicating engineering time to keep the release branch
builds passing. </p>
</li>
<li><p>Keeping the code flowing also means paying into this new system. </p>
</li>
<li><p>When the team identifies a bottleneck, the
Manager should be able to allow the team to remove it (e.g., fix CI tests that have a flakeyness higher than 20%).</p>
</li>
</ul>
<h3 id="upper-management">Upper Management</h3>
<p>Before frequent deploys, upper management could evaluate the team
on the release boundaries.</p>
<h3 id="mechanisms-to-achieve-">Mechanisms to achieve:</h3>
<ul>
<li><p>Surface the Accelerate metrics for our projects and make them
available, with context, to our management.</p>
</li>
<li><p>Surface our uptime or equivalent for our applications.</p>
</li>
<li><p>Make sure to provide our management team with the same high-level information about large chunks of functionality that are shipping.</p>
</li>
<li><p>If you are an upper management person, understand that change takes time and be firm
about holding your teams accountable for high-level goals but flexible about how they achieve them. <strong> Trust, but verify. </strong></p>
</li>
</ul>
